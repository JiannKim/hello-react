// 6.4 응용
/*
    지금까지 배운 개념을 응용해 고정된 배열을 렌더링하는 것이 아닌, 동적인 배열을 렌더링하는 것을 구현해 보자.
    그리고 index 값을 key로 사용하면 리렌더링이 비효율적이라고 배웠는데,
    이러한 상황에 어떻게 고유한 값을 만들 수 있는지도 알아보자.

    실습 순서
    초기상태 설정하기 -> 데이터 추가 기능 구현하기 -> 데이터 제거 기능 구현하기
*/

// 6.4.1 초기 상태 설정하기
/*
    IterationSample 컴포넌트에서 useState를 사용하여 상태를 설정한다.
    세 가지 상태를 사용할 텐데 하나는 데이터 배열이고 다른 하나는 텍스트를 입력할 수 있는 input의 상태이다.
    마지막 하나는 데이터 배열에서 새로운 항목을 추가할 때 사용할 고유 id를 위한 상태이다.

    IterationSample.js에서 문자열로 이루어진 배열을 객체 형태로 코드를 수정하자.

    리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 한다.
    이를 불변성 유지라고 하는데, 불변성 유지를 해 주어야 나중에 리액트 컴포넌트의 성능을 최적화할 수 있다.
    이에 대한 자세한 내용은 책에서 추후 알아볼 것이다.
*/

// 6.4.3 데이터 제거 기능 구현하기
/*
    각 항목을 더블클릭했을 때 해당 항목이 화면에서 사라지는 기능을 구현해 보자.
    이번에도 마찬가지로 불변성을 유지하면서 업데이트 해야 한다.
    불변성을 유지하면서 배열의 특정 항목을 지울 때는 배열의 내장 함수 filter를 사용한다.
    filter 함수를 사용하면 배열에서 특정 조건을 만족하는 원소들만 쉽게 분류할 수 있다.

    예시코드: 
    const numbers = [1,2,3,4,5,6];
    const biggerThanThree = numbers.filter(number => number > 3); // 3보다 큰 수만 렌더링
    // result: [4,5,6]

    filter 함수의 인자에 분류하고 싶은 조건을 반환하는 함수를 넣어 주면 쉽게 분류할 수 있다.
    이 filter 함수를 응용하여 특정 배열에서 특정 원소만 제외시킬 수도 있다.

    예시코드:
    const numbers = [1,2,3,4,5,6];
    const withoutThree = numbers.filter(number => number !== 3) // 배열 원소중에 3이 아닌것들만 렌더링(3을 제외한 모든 원소)
    // result: [1,2,4,5,6]

    이제 IterationSample.js에서 filter 함수를 사용하여 요소를 더블클릭했을 때 삭제 시키는 기능을 구현해보자.
    이벤트 명은 onDoubleClick이다.
 */

// 6.5 정리
/*
    반복되는 데이터를 렌더링하는 법을 배웠다.
    이를 응용하여 유동적인 배열을 다뤄봤다.
    컴포넌트 배열을 렌더링할 때는 key값 설정에 항상 주의해야 한다.
    또 key값은 언제나 유일해야 한다. 만일 key값이 중복된다면 렌더링 과정에서 오류가 발생한다.

    상태 안에서 배열을 변형할 때는 배열에 직접 접근해서 수정하는 것이 아니라 concat이나 filter등
    배열 내장 함수를 사용하여 새로운 배열을 만든 후 이를 새로운 상태로 설정해야 한다. 즉 불변성을 지켜주어야 한다.
 */